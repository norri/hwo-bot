// Generated by CoffeeScript 1.3.3
(function() {
  var AI, Advanced_Strategy, Helper, Logger, root,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  AI = require('./ai').AI;

  Helper = require('./helper');

  Logger = require('./logger');

  Advanced_Strategy = (function(_super) {

    __extends(Advanced_Strategy, _super);

    function Advanced_Strategy() {
      Advanced_Strategy.__super__.constructor.call(this);
    }

    Advanced_Strategy.prototype.defence = function(ball, opponent) {
      var estimatedVector, firstVector, ownSidePrediction;
      Logger.log("AI", "defence");
      firstVector = this.predictFirstPosition(ball);
      console.log("Test: defence first vector rigth: " + firstVector);
      estimatedVector = this.estimateDirectionBack(firstVector, opponent);
      ownSidePrediction = this.predictSideCollision(estimatedVector);
      return {
        y: ownSidePrediction.y,
        hit: 'center'
      };
    };

    Advanced_Strategy.prototype.estimateDirectionBack = function(vector, opponent) {
      var factor, newVector;
      factor = 1.0;
      newVector = Helper.clone(vector);
      if (this._ballIsMovingDownBeforeCollision(vector)) {
        if (this._opponentIsHigherThanBall(opponent, vector)) {
          factor = 1.2;
        } else if (this._opponentIsLowerThanBall(opponent, vector)) {
          factor = 0.8;
        }
      } else if (this._ballIsMovingUpBeforCollision(vector)) {
        if (this._opponentIsHigherThanBall(opponent, vector)) {
          factor = 0.8;
        } else if (this._opponentIsLowerThanBall(opponent, vector)) {
          factor = 1.2;
        }
      }
      newVector.dx = -newVector.dx;
      newVector.dy = factor * newVector.dy;
      return newVector;
    };

    Advanced_Strategy.prototype._ballIsMovingDownBeforeCollision = function(vector) {
      return vector.dy > 0;
    };

    Advanced_Strategy.prototype._ballIsMovingUpBeforCollision = function(vector) {
      return vector.dy < 0;
    };

    Advanced_Strategy.prototype._opponentIsHigherThanBall = function(opponent, vector) {
      return (opponent.y + opponent.height) < vector.y;
    };

    Advanced_Strategy.prototype._opponentIsLowerThanBall = function(opponent, vector) {
      return opponent.y > vector.y;
    };

    Advanced_Strategy.prototype.attack = function(ball, opponent) {
      var factor, firstVector, hitCoordinateEstimations, hitDirection;
      Logger.log("AI", "attack");
      console.log("Test: attack ball: " + ball.position.x + ", " + ball.position.y);
      firstVector = this.predictFirstPosition(ball);
      console.log("Test: attack first vector left: " + firstVector.y);
      hitCoordinateEstimations = this.calculateHits(firstVector);
      factor = this.selectBestFactorForHit(hitCoordinateEstimations, opponent);
      Logger.log("AI", "factor: " + factor);
      hitDirection = 'center';
      if (factor < 1 && firstVector.dy > 0) {
        hitDirection = 'up';
      } else if (factor < 1 && firstVector.dy < 0) {
        hitDirection = 'down';
      } else if (factor > 1 && firstVector.dy > 0) {
        hitDirection = 'down';
      } else if (factor > 1 && firstVector.dy < 0) {
        hitDirection = 'up';
      }
      return {
        y: firstVector.y,
        hit: hitDirection
      };
    };

    Advanced_Strategy.prototype.calculateHits = function(vector) {
      var estimations, factor, hitEstimateVector, index, newVector, results, _i, _len;
      estimations = [0.8, 1.0, 1.2];
      results = [];
      for (index = _i = 0, _len = estimations.length; _i < _len; index = ++_i) {
        factor = estimations[index];
        newVector = this.estimateNewAttackDirection(vector, factor);
        hitEstimateVector = this.predictSideCollision(newVector);
        results[index] = {
          y: hitEstimateVector.y,
          factor: factor
        };
      }
      return results;
    };

    Advanced_Strategy.prototype.estimateNewAttackDirection = function(vector, factor) {
      var newVector;
      newVector = Helper.clone(vector);
      newVector.dx = -newVector.dx;
      newVector.dy = factor * newVector.dy;
      return newVector;
    };

    Advanced_Strategy.prototype.selectBestFactorForHit = function(hitEstimations, opponent) {
      var distanceFromOpponent, estimate, factor, maxDistance, _i, _len;
      maxDistance = 0;
      factor = 1.0;
      for (_i = 0, _len = hitEstimations.length; _i < _len; _i++) {
        estimate = hitEstimations[_i];
        distanceFromOpponent = Math.abs(estimate.y - opponent.y + opponent.height / 2);
        Logger.log("AI", "Estimate: " + estimate.y + ", factor: " + estimate.factor + ", distance from opponent: " + distanceFromOpponent);
        if (distanceFromOpponent > maxDistance) {
          maxDistance = distanceFromOpponent;
          factor = estimate.factor;
        }
      }
      return factor;
    };

    return Advanced_Strategy;

  })(AI);

  root = typeof exports !== "undefined" && exports !== null ? exports : window;

  root.Advanced_Strategy = Advanced_Strategy;

}).call(this);
